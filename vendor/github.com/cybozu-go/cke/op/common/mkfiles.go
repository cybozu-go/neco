package common

import (
	"archive/tar"
	"bytes"
	"context"
	"path/filepath"
	"strings"
	"sync"

	"github.com/cybozu-go/cke"
	"github.com/cybozu-go/well"
)

type fileData struct {
	name    string
	dataMap map[string][]byte
}

// FilesBuilder is a database of files to be created in nodes.
// It also implements cke.Commander.
type FilesBuilder struct {
	nodes []*cke.Node
	files []fileData
}

// NewFilesBuilder creates a new FilesBuilder.
func NewFilesBuilder(nodes []*cke.Node) *FilesBuilder {
	return &FilesBuilder{nodes: nodes}
}

// AddFile adds a file to the builder.
// The contents of the file will be generated by f.
func (c *FilesBuilder) AddFile(ctx context.Context, name string, f func(context.Context, *cke.Node) ([]byte, error)) error {
	var mu sync.Mutex
	dataMap := make(map[string][]byte)

	env := well.NewEnvironment(ctx)
	for _, n := range c.nodes {
		n := n
		env.Go(func(ctx context.Context) error {
			data, err := f(ctx, n)
			if err != nil {
				return err
			}
			mu.Lock()
			dataMap[n.Address] = data
			mu.Unlock()
			return nil
		})
	}
	env.Stop()
	err := env.Wait()
	if err != nil {
		return err
	}

	c.files = append(c.files, fileData{name, dataMap})
	return nil
}

// AddKeyPair adds a certificate and private key pair to the builder.
// The certificate data and private key data will be generated by f.
func (c *FilesBuilder) AddKeyPair(ctx context.Context, name string,
	f func(context.Context, *cke.Node) (cert, key []byte, err error)) error {
	var mu sync.Mutex
	certMap := make(map[string][]byte)
	keyMap := make(map[string][]byte)

	env := well.NewEnvironment(ctx)
	for _, n := range c.nodes {
		n := n
		env.Go(func(ctx context.Context) error {
			certData, keyData, err := f(ctx, n)
			if err != nil {
				return err
			}
			mu.Lock()
			certMap[n.Address] = certData
			keyMap[n.Address] = keyData
			mu.Unlock()
			return nil
		})
	}
	env.Stop()
	err := env.Wait()
	if err != nil {
		return err
	}

	c.files = append(c.files, fileData{name + ".crt", certMap})
	c.files = append(c.files, fileData{name + ".key", keyMap})
	return nil
}

// Run implements cke.Commander.
func (c *FilesBuilder) Run(ctx context.Context, inf cke.Infrastructure) error {
	bindMap := make(map[string]cke.Mount)
	for _, f := range c.files {
		parentDir := filepath.Dir(f.name)
		if _, ok := bindMap[parentDir]; ok {
			continue
		}
		bindMap[parentDir] = cke.Mount{
			Source:      parentDir,
			Destination: filepath.Join("/mnt", parentDir),
			Label:       cke.LabelPrivate,
		}
	}
	binds := make([]cke.Mount, 0, len(bindMap))
	for _, m := range bindMap {
		binds = append(binds, m)
	}

	env := well.NewEnvironment(ctx)
	for _, n := range c.nodes {
		n := n
		env.Go(func(ctx context.Context) error {
			buf := new(bytes.Buffer)
			tw := tar.NewWriter(buf)
			for _, f := range c.files {
				data := f.dataMap[n.Address]
				hdr := &tar.Header{
					Name: f.name,
					Mode: 0644,
					Size: int64(len(data)),
				}
				if err := tw.WriteHeader(hdr); err != nil {
					return err
				}
				if _, err := tw.Write(data); err != nil {
					return err
				}
			}
			if err := tw.Close(); err != nil {
				return err
			}
			data := buf.String()

			arg := "/usr/local/cke-tools/bin/write_files /mnt"
			ce := inf.Engine(n.Address)
			return ce.RunWithInput(cke.ToolsImage, binds, arg, data)
		})
	}
	env.Stop()
	return env.Wait()
}

// Command implements cke.Commander
func (c *FilesBuilder) Command() cke.Command {
	fileNames := make([]string, len(c.files))
	for i, f := range c.files {
		fileNames[i] = f.name
	}
	return cke.Command{
		Name:   "make-files",
		Target: strings.Join(fileNames, ","),
	}
}
